#' Runs CAPE
#'
#' This function takes in a data object and genotype object that
#' have been formatted for cape, as well as a string identifying
#' a parameter file. It runs cape on the data using the parameters
#' specified in the file.
#' 
#' This function assumes you already have all required libraries 
#' and functions loaded.
#'
#' @param pheno_obj the cape object holding the phenotype data returned by 
#' @param geno_obj the genotype object
#' @param results_file the name of the saved data_obj RDS file. The base 
#' name is used as the base name for all saved RDS files.
#' @param p_or_q A threshold indicating the maximum adjusted p value 
#' considered significant. Or, if FDR p value correction is used, the
#' the maximum q value considered significant.
#' @param n_cores The number of CPUs to use if run_parallel is set to TRUE
#' @param initialize_only, If TRUE, cape will not be run. Instead an initialized
#' data object will be returned. This data object will contain normalized and mean-centered
#' trait values, and eigentraits, and will have covariates specified. However, the 
#' singlescan, pairscan, etc. will not be run.
#' @param verbose Whether progress should be printed to the screen
#' @param run_parallel boolean, if TRUE runs certain parts of the code as parallel blocks
#' @param param_file yaml full path to the parameter file
#' @param yaml_params yaml string containing the parameters. Either the param_file or 
#' yaml_params can be null.
#' @param results_path path that results should be written to.
#' @param plot_pdf boolean, TRUE by default. If FALSE no pdf will be generated by the analysis.
#' 
#' @return This function invisibly returns the data object with all final 
#' data included. In addition, data saved to the data_obj$results_path directory
#' 
#' @importFrom utils read.table
#' 
#' @examples 
#' \dontrun{
#' final_data_obj <- run_cape(pheno_obj, geno_obj)
#' }
#' 
#' @export
run_query_cape <- function(pheno_obj, geno_obj, query_genotype, 
  results_file = "cross.RDS", p_or_q = 0.05, n_cores = 4, 
  initialize_only = FALSE, verbose = TRUE, run_parallel = FALSE, 
  param_file = NULL, yaml_params = NULL, results_path = NULL, plot_pdf = TRUE){
  
  #add the query_genotype to the geno_obj, so we can find it later with get_marker_num
  expand_query <- matrix(NA, nrow = nrow(query_genotype), ncol = ncol(geno_obj))
  rownames(expand_query) <- rownames(geno_obj)
  colnames(expand_query) <- colnames(geno_obj)
  for(i in 1:ncol(expand_query)){
    expand_query[,i] <- query_genotype
  }
  geno_obj <- abind(geno_obj, expand_query, along = 3)
  dimnames(geno_obj)[[3]][length(dimnames(geno_obj)[[3]])]  <- "query"
  pheno_obj$geno_names$locus <- dimnames(geno_obj)[[3]]
  pheno_obj$chromosome <- c(pheno_obj$chromosome, 0)
  pheno_obj$marker_num <- c(pheno_obj$marker_num, (max(pheno_obj$marker_num)+1))
  pheno_obj$marker_location <- c(pheno_obj$marker_location, 1)

  # Instantiate the Cape R6 object
  data_obj <- Cape$new(
  		parameter_file = param_file,
  		yaml_parameters = yaml_params,
  		results_path = results_path,
  		pheno = pheno_obj$pheno,
  		chromosome = pheno_obj$chromosome,
  		marker_num = pheno_obj$marker_num,
  		marker_location = pheno_obj$marker_location,
  		geno_names = pheno_obj$geno_names,
  		geno = geno_obj,
  		plot_pdf = plot_pdf
  )

  #add the query genotype to the data_obj so we can access it later
  data_obj$query_genotype <- query_genotype
  
  results_base_name <- gsub(".RDS", "", results_file)
    
  # since this is the main data_obj, we can't allow it to return FALSE, 
  #check for the file first
  prior_data_obj <- data_obj$read_rds(results_file)
  if (isFALSE(prior_data_obj)) {
    data_obj <- compare_markers(data_obj, geno_obj)
  } else {
    # things can get pretty confusing if these values don't match between 
    #the parameter file and the old data_obj
    prior_data_obj$save_results <- data_obj$save_results
    prior_data_obj$use_saved_results <- data_obj$use_saved_results
    data_obj <- prior_data_obj
  }
  
  #===============================================================
  # figure out how to synchronize get_eigentraits and
  # the calculation of the kinship matrix. They both may
  # remove individuals. Maybe trim the kinship object to match
  # the eigentraits
  #===============================================================
  #if we want to use a kinship correction
  if(as.logical(data_obj$use_kinship)){
    kin_file_name <- paste0(results_base_name, "_kinship.RDS")
    kin_obj <- data_obj$read_rds(kin_file_name)
    
    if(isFALSE(kin_obj)){
      #if there isn't a kinship object already, we need to make one
      kin_obj <- kinship(data_obj, geno_obj, type = "overall", 
      pop = data_obj$pop)
      data_obj$save_rds(kin_obj, kin_file_name)
    }

    #===============================================================
    # We need a complete genotype matrix to calculate the kinship
    # adjusted genotypes later on.
    # Check for missing values in the genotype matrix.
    # If there are missing values, impute them.
    # Write out the imputed matrix, or read this in if it already
    # exists.
    #===============================================================
    #we need to impute the missing values
    imp_data_file <- paste0(results_base_name, "_data_imputed.RDS")
    imp_geno_file <- paste0(results_base_name, "_geno_imputed.RDS")

    # check if there is already a saved genotype object
    geno <- data_obj$read_rds(imp_geno_file)

    if (isFALSE(geno)) {  #if the imputation hasn't been done already
      geno <- get_geno(data_obj, geno_obj)
      missing_vals <- which(is.na(geno))

      if (length(missing_vals) > 0) { #if there are missing values, impute them
        message("There are missing values in geno_obj. Running impute_missing_geno...\n")
        geno_imp <- impute_missing_geno(data_obj, geno_obj = geno_obj, k = 10, 
        	ind_missing_thresh = 0, marker_missing_thresh = 0, prioritize = "fewer",
        	max_region_size = NULL, min_region_size = NULL, run_parallel = run_parallel,
        	verbose = verbose, n_cores = n_cores)

        # update and save the data_obj
        data_obj <- geno_imp$data_obj
        data_obj$save_rds(data_obj, imp_data_file)

        # update and save the geno_obj
        geno_obj <- geno_imp$geno_obj
        data_obj$save_rds(geno_obj, imp_geno_file)
      
        # recalculate the kinship matrix with the updated objects
        #kin_obj <- kinship(data_obj, geno_obj, type = "overall", pop = data_obj$pop)
        #data_obj$save_rds(kin_obj, kin_file_name)

      } #end case for when there are missing values but no imputed genotypes

    } else { #if the imputation has been done, then it must have been done for the data_obj too
      #data_obj <- geno_imp$data_obj
      geno_obj <- geno
    }

  }
    
  if(verbose){cat("Removing unused markers...\n")}
  combined_data_obj <- delete_underscore(data_obj, geno_obj)
  data_obj <- combined_data_obj$data_obj
  geno_obj <- combined_data_obj$geno_obj
  #str(geno_obj)  

  data_obj <- remove_unused_markers(data_obj, geno_obj, verbose = verbose)
  
  #because the genotype object can be changed by the above step, 
  #save the final version. (or change the above step so it doesn't 
  final_geno_file <- paste0(results_base_name, "_geno.RDS")
  data_obj$save_rds(geno_obj, final_geno_file)

  #str(data_obj$geno_names)
  #str(dimnames(geno_obj))

  if(!is.null(data_obj$covariates)){
    if(verbose){cat("Running pheno2covar...\n")}
    data_obj <- pheno2covar(data_obj, data_obj$covariates)
  }
  if(!is.null(data_obj$marker_covariates)){
    if(verbose){cat("Running marker2covar...\n")}
    data_obj <- marker2covar(data_obj, geno_obj, markers = data_obj$marker_covariates)
  }
  
  data_obj <- select_pheno(data_obj, pheno_which = data_obj$traits)	
  
  if(length(grep("eig", data_obj$scan_what, ignore.case = TRUE)) > 0){
    data_obj <- get_eigentraits(
      data_obj, 
      scale_pheno = as.logical(data_obj$traits_scaled), 
      normalize_pheno = as.logical(data_obj$traits_normalized)
    )
    
    if(data_obj$save_results){
      if (data_obj$plot_pdf) {
        if(verbose){cat("Plotting svd.pdf...\n")}
        data_obj$plotSVD("svd.pdf")
      }
      if(verbose){cat("Plotting svd.jpg...\n")}
      data_obj$plotSVD("svd.jpg")
    }
    
    # TODO update select_eigentraits
    if(verbose){cat("Selecting eigentraits...\n")}
    data_obj <- select_eigentraits(data_obj, traits_which = data_obj$eig_which)
  }
  if(verbose){cat("Saving data_obj into rds file...\n")}
  data_obj$save_rds(data_obj, results_file)

  if(initialize_only){
    return(data_obj)
  }
  
  #===============================================================
  # run singlescan
  #===============================================================
  if(verbose){cat("Running Singlescan...\n")}
  singlescan_results_file <- paste0(results_base_name, "_singlescan.RDS")
  
  singlescan_obj <- data_obj$read_rds(singlescan_results_file)
  
  if(!data_obj$use_kinship) {
    kin_obj <- NULL
  }
  
  if (isFALSE(singlescan_obj)) {
      
      singlescan_obj <- singlescan(
        data_obj, geno_obj, kin_obj = kin_obj, n_perm = data_obj$singlescan_perm,
        alpha = data_obj$alpha, verbose = verbose, run_parallel = run_parallel,
        n_cores = n_cores, model_family = "gaussian", overwrite_alert = FALSE
      )
      
      data_obj$save_rds(singlescan_obj, singlescan_results_file)
      
      if(data_obj$save_results){
        if(verbose){cat("Plotting singlescan standardized results...\n")}
        for(ph in 1:ncol(singlescan_obj$singlescan_effects)){
          filename <- paste0("Singlescan_", colnames(singlescan_obj$singlescan_effects)[ph], "_Standardized.jpg")
          data_obj$plotSinglescan(filename, singlescan_obj, width = 20, height = 6, 
            units = "in", res = 300, standardized = TRUE, allele_labels = NULL, 
            alpha = data_obj$alpha, include_covars = TRUE, line_type = "l", pch = 16, cex = 0.5, 
            lwd = 3, traits = colnames(singlescan_obj$singlescan_effects)[ph])
        }
      }
      
      if(data_obj$save_results){
        if(verbose){cat("Plotting singlescan effects results...\n")}
        for(ph in 1:ncol(singlescan_obj$singlescan_effects)){
          filename <- paste0("Singlescan_", colnames(singlescan_obj$singlescan_effects)[ph], "_Effects.jpg")
          data_obj$plotSinglescan(filename, singlescan_obj, width = 20, height = 6, units = "in", res = 300,
            standardized = FALSE, allele_labels = NULL, alpha = data_obj$alpha, include_covars = TRUE,
            line_type = "l", pch = 16, cex = 0.5, lwd = 3, traits = colnames(singlescan_obj$singlescan_effects)[ph])
        }
      }
  }
  
  #===============================================================
  # run pairscan
  # for this pairscan, we pull out the specified marker and 
  # test it against all other markers in the genome.
  #===============================================================
  if(verbose){cat("Running pairscan...\n")}
  pairscan_file <- paste0(results_base_name, "_pairscan.RDS")
  
  pairscan_obj <- data_obj$read_rds(pairscan_file)
  
  if (isFALSE(pairscan_obj) | is.null(data_obj$geno_for_pairscan)) {
      
    pairscan_obj <- pairscan_query(data_obj, geno_obj, query_genotype, 
        scan_what = data_obj$scan_what, pairscan_null_size = data_obj$pairscan_null_size, 
        min_per_genotype = data_obj$min_per_genotype, max_pair_cor = data_obj$max_pair_cor, 
        verbose = verbose, num_pairs_limit = Inf, overwrite_alert = FALSE, 
        run_parallel = run_parallel, n_cores = n_cores, kin_obj = kin_obj)

      data_obj$save_rds(pairscan_obj, pairscan_file)
      data_obj$save_rds(data_obj, results_file)

  }
  
  #===============================================================
  # run reparameterization
  #===============================================================
  
  if(verbose){cat("Running reparameterization...\n")}
  data_obj <- error_prop(data_obj, pairscan_obj, perm = FALSE, verbose = verbose,
    n_cores = n_cores, run_parallel = run_parallel)
  data_obj$save_rds(data_obj, results_file)

  data_obj <- error_prop(data_obj, pairscan_obj, perm = TRUE, verbose = verbose,
    n_cores = n_cores, run_parallel = run_parallel)
    data_obj$save_rds(data_obj, results_file)
  
  data_obj <- calc_p(data_obj, pval_correction = data_obj$pval_correction)
 
  data_obj <- direct_influence(data_obj, pairscan_obj, 
    transform_to_phenospace = data_obj$transform_to_phenospace, verbose = verbose, 
    pval_correction = data_obj$pval_correction, save_permutations = TRUE, 
    n_cores = n_cores)
    data_obj$save_rds(data_obj, results_file)

if(data_obj$save_results){
      pdf(file.path(results_path, paste0("Variant_Influences.pdf")), width = 8, height = 5)
      plot_variant_influences_query(data_obj, p_or_q = p_or_q)
      dev.off()
    }

  if(data_obj$save_results){
    if(verbose){cat("Saving Variant_influences results...\n")}
    data_obj$writeVariantInfluences("Variant_Influences.csv", p_or_q = max(c(p_or_q, 0.2)))
    if(verbose){cat("Saving Variant_Interactions results...\n")}
    data_obj$writeVariantInfluences("Variant_Influences_Interactions.csv", 
      include_main_effects = FALSE, p_or_q = max(c(p_or_q, 0.2)))
  }

  data_obj$save_rds(data_obj, results_file)
  
  invisible(data_obj)
  
  
}
